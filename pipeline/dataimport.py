#!/usr/bin/env python3
import pandas as pd
import numpy as np

from . import CellAttr

def diagnostic_series(
        time,
        sin_specs = None,
        noise_magn = 0,
        displ = 0):
    """
    Generates a diagnostic/artificial time series

    Parameters:
    -----------
    time: 1D array-like
        time axis
    sin_specs: 2D array-like with N rows and 3 columns, optional
        specifications for the N sinusoid components; the columns are
        frequency, amplitude, and phase
    noise_magn: scalar, optional
        magnitude of Gaussian noise
    displ: scalar, optional
        vertical axis displacement

    Returns:
    --------
    1D numpy array that contains the time series
    """
    l = len(time)

    if np.any(sin_specs):
        components = np.ndarray(shape = (len(sin_specs), l))
        for counter, spec in enumerate(sin_specs):
            components[counter] = spec[1] * \
                    np.sin((2 * np.pi * spec[0]) * time + spec[2])
        sinusoids = np.sum(components, axis = 0)
    else:
        sinusoids = np.zeros(l)

    noise = noise_magn * np.random.normal(0, 1, size = l)

    return displ + sinusoids + noise

def import_timeseries(filename, remain = 1):
    """
    Imports CSVs that contain flavin experiment timeseries along with some
    cell information, as produced by Export_Flavinexpostest3.m

    Parameters:
    -----------
    filename: string
        name of CSV file
    remain: scalar, optional
        the proportion of the duration of the experiment a particular cell
        must remain in order for it to be included.
        For example, remain = 0.80 means I include only cells that are
        present for at least 80% of the experiment.

    Returns:
    --------
    df: pandas dataframe that contains information for each cell
        cellID: the running element number generated by MATLAB that functions
                as the ID
        positions: position within microfluidic device
        distfromcentre: distance from centre of aperture
        tp_XXX: measurement at each timepoint
    """
    # drops NaNs when importing -- these should correspond to cells outside of
    # aperture
    df = pd.read_csv(filename, header = 0).dropna()
    df = df.reset_index(drop = True)
    # drops cells that are not present for some duration of experiment
    rows_to_drop = [row
            for row in range(len(df))
            if sum(df.iloc[row,3:] == 0) > ((1 - remain) * len(df.iloc[row,3:]))
            ]
    df = df.drop(rows_to_drop, axis = 0)
    # replaces zeros with NaNs -- these should be no fluorescent readings, i.e.
    # no cell at that timepoint
    df.replace(0, np.nan, inplace=True)
    return df

def import_births(filename):
    """
    Import birth times

    Returns:
    --------
    df: pandas dataframe that contains all birth times identified for each cell
        id: the running element number generated by MATLAB that functions as
            the ID
        birthtime_XXX: time (min) at which a birth is identified
    """
    df = pd.read_csv(filename)
    return df

def import_categories(filename):
    """
    Import manually-defined oscillation categories

    Returns:
    --------
    dcategory: list of integers corresponding to categories
        1 - oscillating
        2 - unsure
        3 - not oscillating
    """
    dcategory = []
    with open(filename, 'r') as fobj:
        c = fobj.readlines()
        dcategory = [int(x.strip()) for x in c]
    return dcategory

def CellAttr_from_datasets(timeseries_df,
        categories_array,
        births_df,
        sampling_pd = 2.5):
    """
    Adds imported fluorescent measurements, births, and categories into a list
    of CellAttr objects

    Parameters:
    -----------
    timeseries_df = pandas dataframe,
        cellids, MATLABids, positions, and distances from centre of aperture,
        as imported by import_timeseries
    categories_array = 1D array,
        manually-defined oscillation categories, as imported by
        import_categories
    births_df = pandas dataframe,
        birth times for each cell, as imported by import_births
    sampling_pd = float,
        sampling period

    Returns:
    --------
    test_data = list of CellAttr objects
        these CellAttr attributes are filled: cellid, MATLABid, position,
        distfromcentre, time, fluo, category, births
    """
    test_data = [CellAttr(ii) for ii in range(len(timeseries_df))]
    for ii, cell in enumerate(test_data):
        cell.MATLABid = timeseries_df.cellID.iloc[ii]
        cell.position = timeseries_df.position.iloc[ii]
        cell.distfromcentre = timeseries_df.distfromcentre.iloc[ii]

        l = len(timeseries_df.iloc[ii,3:])
        cell.time = np.linspace(0, sampling_pd * (l - 1), l)
        # dummy attribute to hold timeseries before I assign it to a more appropriate sub-attribute in cell.fluo
        cell.y = timeseries_df.iloc[ii,3:].to_numpy()

        cell.births = births_df.iloc[cell.MATLABid - 1,1:].dropna().to_numpy()

    return test_data
